<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>XR Video (AR/MR) + Texto 3D Extrusión</title>
  <style>
    html,body{margin:0;height:100%;background:#000;overflow:hidden}
    #overlay{
      position:fixed;inset:0;display:grid;place-items:center;
      background:rgba(0,0,0,.85);color:#fff;font-family:system-ui,Arial;
      z-index:10;text-align:center;padding:24px;
    }
    .card{
      max-width:820px;width:100%;
      background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.12);
      border-radius:18px;padding:20px;
    }
    button{
      padding:14px 18px;border-radius:14px;
      border:1px solid rgba(255,255,255,.2);
      background:rgba(255,255,255,.1);
      color:#fff;cursor:pointer;margin:6px;
    }
    .small{
      opacity:.75;font-size:14px;line-height:1.4;margin-top:10px;
      white-space:pre-wrap;text-align:left
    }
  </style>
</head>
<body>

<div id="overlay">
  <div class="card" id="card">
    <h2 style="margin:0 0 10px 0;">Passthrough + vídeo flotante + texto 3D</h2>
    <p style="margin:0 0 14px 0;opacity:.9;">
      1) Inicia el vídeo (muted). 2) Entra en AR (passthrough). Si AR no está, entra en VR.
    </p>
    <div>
      <button id="start">1) Iniciar vídeo</button>
      <button id="enterAR" disabled>2) Entrar en AR (passthrough)</button>
      <button id="enterVR" disabled>Entrar en VR (fallback)</button>
    </div>
    <div class="small" id="log"></div>
  </div>
</div>

<script type="module">
  import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";
  import { FontLoader } from "https://unpkg.com/three@0.160.0/examples/jsm/loaders/FontLoader.js";
  import { TextGeometry } from "https://unpkg.com/three@0.160.0/examples/jsm/geometries/TextGeometry.js";
  import { CUES, VIDEO_URL } from "./cues.js";

  const logEl = document.getElementById("log");
  const log = (m) => { logEl.textContent = (logEl.textContent ? logEl.textContent + "\n" : "") + m; };

  // --- Renderer transparente para passthrough ---
  const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.xr.enabled = true;
  document.body.appendChild(renderer.domElement);

  const scene = new THREE.Scene();
  scene.background = null; // clave para AR

  const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 50);
  camera.position.set(0, 1.6, 2.2);

  scene.add(new THREE.HemisphereLight(0xffffff, 0x222222, 1.2));

  // --- Vídeo (Quest friendly) ---
  const video = document.createElement("video");
  video.src = VIDEO_URL;
  video.crossOrigin = "anonymous";
  video.muted = true;
  video.setAttribute("muted", "");
  video.volume = 0;
  video.playsInline = true;
  video.setAttribute("playsinline", "");
  video.setAttribute("webkit-playsinline", "");
  video.preload = "auto";
  video.loop = false;

  // Añadir al DOM (a veces necesario para decodificar en XR)
  video.style.position = "fixed";
  video.style.left = "-9999px";
  video.style.top = "-9999px";
  video.width = 1; video.height = 1;
  document.body.appendChild(video);

  const videoTex = new THREE.VideoTexture(video);
  videoTex.colorSpace = THREE.SRGBColorSpace;

  // Pantalla de vídeo
  const screen = new THREE.Mesh(
    new THREE.PlaneGeometry(1.6, 0.9),
    new THREE.MeshBasicMaterial({ map: videoTex, transparent: true })
  );
  screen.position.set(0, 1.6, -2.2);
  scene.add(screen);

  // Panel oscuro detrás para “modo cine”
  const dimmer = new THREE.Mesh(
    new THREE.PlaneGeometry(6, 4),
    new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.55 })
  );
  dimmer.position.set(0, 1.6, -2.6);
  scene.add(dimmer);

  // ---------- TEXTO 3D EXTRUIDO ----------
  const fontLoader = new FontLoader();
  const FONT_URL = "https://unpkg.com/three@0.160.0/examples/fonts/helvetiker_regular.typeface.json";
  let loadedFont = null;

  // Grupo de texto
  let textGroup = null;

  // Material con luz para que se note la extrusión
  const textMaterial = new THREE.MeshStandardMaterial({
    color: 0xffffff,
    roughness: 0.25,
    metalness: 0.05
  });

  // Ajustes
  const TEXT_SIZE = 0.085;      // tamaño letra (m aprox)
  const TEXT_DEPTH = 0.02;      // grosor
  const TEXT_BEVEL = true;
  const BEVEL_THICKNESS = 0.004;
  const BEVEL_SIZE = 0.003;

  // Más cerca del usuario
  const TEXT_POS = new THREE.Vector3(0, 1.35, -1.05);

  const LINE_GAP = 0.11;

  async function ensureFont() {
    if (loadedFont) return loadedFont;
    return new Promise((resolve, reject) => {
      fontLoader.load(
        FONT_URL,
        (font) => { loadedFont = font; resolve(font); },
        undefined,
        (err) => reject(err)
      );
    });
  }

  function disposeTextGroup(g) {
    if (!g) return;
    g.traverse(obj => {
      if (obj.isMesh) obj.geometry?.dispose();
    });
    scene.remove(g);
  }

  function createLineMesh(font, line) {
    const geo = new TextGeometry(line, {
      font,
      size: TEXT_SIZE,
      height: TEXT_DEPTH,
      curveSegments: 10,
      bevelEnabled: TEXT_BEVEL,
      bevelThickness: BEVEL_THICKNESS,
      bevelSize: BEVEL_SIZE,
      bevelOffset: 0,
      bevelSegments: 3
    });

    geo.computeBoundingBox();
    geo.computeVertexNormals();

    // Centrar la línea
    const bb = geo.boundingBox;
    const width = (bb.max.x - bb.min.x);
    geo.translate(-width / 2, 0, 0);

    return new THREE.Mesh(geo, textMaterial);
  }

  async function setText3D(lines) {
    const font = await ensureFont();
    const safeLines = Array.isArray(lines) ? lines : [String(lines)];

    disposeTextGroup(textGroup);
    textGroup = new THREE.Group();

    for (let i = 0; i < safeLines.length; i++) {
      const mesh = createLineMesh(font, safeLines[i]);
      const y = ((safeLines.length - 1) * LINE_GAP) / 2 - i * LINE_GAP;
      mesh.position.set(0, y, 0);
      textGroup.add(mesh);
    }

    textGroup.position.copy(TEXT_POS);
    scene.add(textGroup);
  }

  // ---------- CUES ----------
  const cues = [...CUES].sort((a,b)=>a.t-b.t);
  let nextCue = 0;

  function resyncCues(t){
    let idx=-1;
    for(let i=0;i<cues.length;i++){
      if(cues[i].t<=t) idx=i;
      else break;
    }
    nextCue = idx+1;
    if(idx>=0) setText3D(cues[idx].text);
  }

  // ---------- Loop ----------
  renderer.setAnimationLoop(() => {
    if (video.readyState >= 2) videoTex.needsUpdate = true;

    if (!video.paused && !video.ended) {
      const t = video.currentTime;
      while (nextCue < cues.length && t >= cues[nextCue].t) {
        setText3D(cues[nextCue].text);
        nextCue++;
      }
    }

    // Texto mirando al usuario (billboard) manteniendo solo yaw/pitch
    if (textGroup) {
      textGroup.quaternion.copy(camera.quaternion);
    }

    renderer.render(scene, camera);
  });

  window.addEventListener("resize", () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

  // ---------- Sesiones AR/VR ----------
  const btnStart = document.getElementById("start");
  const btnAR = document.getElementById("enterAR");
  const btnVR = document.getElementById("enterVR");

  async function enterSession(mode) {
    if (!navigator.xr) throw new Error("WebXR no disponible en este navegador.");

    const optionalFeatures = [
      "local-floor",
      "bounded-floor",
      "hand-tracking",
      "layers",
      "anchors",
      "hit-test"
    ];

    const session = await navigator.xr.requestSession(mode, { optionalFeatures });
    renderer.xr.setSession(session);
    log(`✅ Sesión iniciada: ${mode}`);

    session.addEventListener("end", () => log(`ℹ️ Sesión finalizada: ${mode}`));
  }

  btnStart.addEventListener("click", async () => {
    try {
      log("Iniciando vídeo (muted)...");
      video.load();
      await video.play();
      resyncCues(video.currentTime);
      log("✅ Vídeo OK. Ya puedes entrar en AR o VR.");

      btnAR.disabled = false;
      btnVR.disabled = false;
    } catch (e) {
      log(`❌ Error vídeo: ${e?.name || "Error"}: ${e?.message || e}`);
    }
  });

  btnAR.addEventListener("click", async () => {
    try {
      const ok = await navigator.xr?.isSessionSupported?.("immersive-ar");
      log(`isSessionSupported(immersive-ar): ${ok}`);
      if (!ok) throw new Error("immersive-ar no soportado en este Quest Browser.");
      await enterSession("immersive-ar");
      document.getElementById("overlay").style.display = "none";
    } catch (e) {
      log(`❌ AR no disponible: ${e?.message || e}\nPrueba VR (fallback).`);
    }
  });

  btnVR.addEventListener("click", async () => {
    try {
      const ok = await navigator.xr?.isSessionSupported?.("immersive-vr");
      log(`isSessionSupported(immersive-vr): ${ok}`);
      if (!ok) throw new Error("immersive-vr no soportado (raro).");
      await enterSession("immersive-vr");
      document.getElementById("overlay").style.display = "none";
    } catch (e) {
      log(`❌ VR no disponible: ${e?.message || e}`);
    }
  });
</script>
</body>
</html>
