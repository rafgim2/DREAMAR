<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>XR Video (AR)</title>
  <style>
    html,body{margin:0;height:100%;background:#000;overflow:hidden}
    #overlay{
      position:fixed;inset:0;display:grid;place-items:center;
      background:rgba(0,0,0,.85);color:#fff;font-family:system-ui,Arial;
      z-index:10;text-align:center;padding:24px;
    }
    .card{
      max-width:820px;width:100%;
      background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.12);
      border-radius:18px;padding:20px;
    }
    button{
      padding:14px 18px;border-radius:14px;
      border:1px solid rgba(255,255,255,.2);
      background:rgba(255,255,255,.1);
      color:#fff;cursor:pointer;margin:6px;
    }
    .small{
      opacity:.75;font-size:14px;line-height:1.4;margin-top:10px;
      white-space:pre-wrap;text-align:left
    }
  </style>
</head>
<body>

<div id="overlay">
  <div class="card">
    <h2>Modo passthrough (AR)</h2>
    <p>Texto con efecto escritura + vídeo en loop</p>
    <button id="start">Iniciar</button>
    <button id="enterAR" disabled>Entrar en AR</button>
    <div class="small" id="log"></div>
  </div>
</div>

<script type="module">
import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";
import { CUES, VIDEO_URL } from "./cues.js";

const log = (m)=>logEl.textContent+=(logEl.textContent?"\n":"")+m;
const logEl = document.getElementById("log");

/* ---------------- FUENTE ---------------- */
let PRISTINA_READY=false;
const font = new FontFace("PristinaAR","url(./PRISTINA.TTF)");
await font.load();
document.fonts.add(font);
PRISTINA_READY=true;

/* ---------------- THREE / XR ---------------- */
const renderer=new THREE.WebGLRenderer({antialias:true,alpha:true});
renderer.setSize(window.innerWidth,window.innerHeight);
renderer.xr.enabled=true;
document.body.appendChild(renderer.domElement);

const scene=new THREE.Scene();
scene.background=null;

const camera=new THREE.PerspectiveCamera(60,window.innerWidth/window.innerHeight,0.1,50);
camera.position.set(0,1.6,2);
scene.add(new THREE.HemisphereLight(0xffffff,0x222222,1.2));

/* ---------------- VIDEO LOOP ---------------- */
const video=document.createElement("video");
video.src=VIDEO_URL;
video.muted=true;
video.loop=true;
video.playsInline=true;
video.setAttribute("playsinline","");
video.setAttribute("webkit-playsinline","");
video.style.position="fixed";
video.style.left="-9999px";
document.body.appendChild(video);

const videoTex=new THREE.VideoTexture(video);
videoTex.colorSpace=THREE.SRGBColorSpace;

const screen=new THREE.Mesh(
  new THREE.PlaneGeometry(1.6,0.9),
  new THREE.MeshBasicMaterial({map:videoTex,transparent:true})
);
screen.position.set(0,1.55,-1.35);
scene.add(screen);

/* ---------------- TEXTO CON ESCRITURA ---------------- */
let textPlane=null;
let typingInterval=null;
const TYPE_SPEED=45; // ms por carácter (ajusta aquí)

function drawTextCanvas(lines, charLimit=null){
  const fontPx=56, lineH=78, pad=36;
  const safe=Array.isArray(lines)?lines:[String(lines)];
  const fontName=PRISTINA_READY?"PristinaAR":"serif";

  // aplica límite de caracteres
  let rendered=[];
  let count=0;
  for(const l of safe){
    if(charLimit===null){ rendered.push(l); continue; }
    const remaining=charLimit-count;
    if(remaining<=0){ rendered.push(""); continue; }
    rendered.push(l.slice(0,remaining));
    count+=l.length;
  }

  const canvas=document.createElement("canvas");
  const ctx=canvas.getContext("2d");
  ctx.font=`${fontPx}px ${fontName}`;
  const w=Math.min(1400,Math.max(...rendered.map(t=>ctx.measureText(t).width))+pad*2);
  const h=rendered.length*lineH+pad*2;
  canvas.width=w; canvas.height=h;

  ctx.font=`${fontPx}px ${fontName}`;
  ctx.textAlign="center";
  ctx.textBaseline="middle";
  ctx.fillStyle="rgba(255,255,255,.96)";
  ctx.shadowColor="rgba(0,0,0,.85)";
  ctx.shadowBlur=20;
  ctx.shadowOffsetY=2;

  let y=pad+lineH/2;
  for(const t of rendered){
    ctx.fillText(t,w/2,y);
    y+=lineH;
  }
  return canvas;
}

function startTyping(lines){
  if(typingInterval) clearInterval(typingInterval);

  let totalChars=lines.join("").length;
  let current=0;

  typingInterval=setInterval(()=>{
    const canvas=drawTextCanvas(lines,current);
    const tex=new THREE.CanvasTexture(canvas);

    if(!textPlane){
      const aspect=canvas.width/canvas.height;
      const h=0.3, w=h*aspect;
      textPlane=new THREE.Mesh(
        new THREE.PlaneGeometry(w,h),
        new THREE.MeshBasicMaterial({map:tex,transparent:true,depthWrite:false})
      );
      textPlane.position.set(0,1.23,-1.05);
      scene.add(textPlane);
    }else{
      textPlane.material.map.dispose();
      textPlane.material.map=tex;
      textPlane.material.needsUpdate=true;
    }

    current++;
    if(current>totalChars) clearInterval(typingInterval);
  }, TYPE_SPEED);
}

/* ---------------- CUES ---------------- */
const cues=[...CUES].sort((a,b)=>a.t-b.t);
let nextCue=0;

function checkCues(){
  const t=video.currentTime;
  while(nextCue<cues.length && t>=cues[nextCue].t){
    startTyping(cues[nextCue].text);
    nextCue++;
  }
}

/* ---------------- LOOP ---------------- */
renderer.setAnimationLoop(()=>{
  if(video.readyState>=2) videoTex.needsUpdate=true;
  checkCues();
  renderer.render(scene,camera);
});

/* ---------------- BOTONES ---------------- */
const btnStart=document.getElementById("start");
const btnAR=document.getElementById("enterAR");

btnStart.onclick=async()=>{
  await video.play();
  btnAR.disabled=false;
};

btnAR.onclick=async()=>{
  if(await navigator.xr.isSessionSupported("immersive-ar")){
    const session=await navigator.xr.requestSession("immersive-ar",{optionalFeatures:["local-floor"]});
    renderer.xr.setSession(session);
    overlay.style.display="none";
  }
};

window.addEventListener("resize",()=>{
  camera.aspect=window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth,window.innerHeight);
});
</script>
</body>
</html>
