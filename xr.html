<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>XR Video (AR/MR)</title>
  <style>
    html,body{margin:0;height:100%;background:#000;overflow:hidden}
    #overlay{
      position:fixed;inset:0;display:grid;place-items:center;
      background:rgba(0,0,0,.85);color:#fff;font-family:system-ui,Arial;
      z-index:10;text-align:center;padding:24px;
    }
    .card{
      max-width:820px;width:100%;
      background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.12);
      border-radius:18px;padding:20px;
    }
    button{
      padding:14px 18px;border-radius:14px;
      border:1px solid rgba(255,255,255,.2);
      background:rgba(255,255,255,.1);
      color:#fff;cursor:pointer;margin:6px;
    }
    .small{
      opacity:.75;font-size:14px;line-height:1.4;margin-top:10px;
      white-space:pre-wrap;text-align:left
    }
  </style>
</head>
<body>

<div id="overlay">
  <div class="card">
    <h2 style="margin:0 0 10px 0;">AR + vídeo + texto “escritura” estable</h2>
    <p style="margin:0 0 14px 0;opacity:.9;">
      El texto se escribe letra a letra sin recolocarse (tamaño fijo por cue).
    </p>
    <div>
      <button id="start">1) Iniciar vídeo</button>
      <button id="enterAR" disabled>2) Entrar en AR</button>
      <button id="enterVR" disabled>Entrar en VR</button>
    </div>
    <div class="small" id="log"></div>
  </div>
</div>

<script type="module">
  import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";
  import { CUES, VIDEO_URL } from "./cues.js";

  const overlay = document.getElementById("overlay");
  const logEl = document.getElementById("log");
  const log = (m) => logEl.textContent += (logEl.textContent ? "\n" : "") + m;

  // ---------- Fuente PRISTINA ----------
  let PRISTINA_READY = false;
  async function loadPristinaFont() {
    try {
      const font = new FontFace("PristinaAR", "url(./PRISTINA.TTF)");
      await font.load();
      document.fonts.add(font);
      PRISTINA_READY = true;
      log("✅ Fuente PRISTINA cargada");
    } catch (e) {
      log("❌ No se pudo cargar PRISTINA.TTF (uso fallback)");
    }
  }
  await loadPristinaFont();
  const fontName = () => (PRISTINA_READY ? "PristinaAR" : "serif");

  // ---------- Three.js ----------
  const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.xr.enabled = true;
  document.body.appendChild(renderer.domElement);

  const scene = new THREE.Scene();
  scene.background = null;

  const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 50);
  camera.position.set(0, 1.6, 2);

  scene.add(new THREE.HemisphereLight(0xffffff, 0x222222, 1.2));

  // ---------- Vídeo (loop) ----------
  const video = document.createElement("video");
  video.src = VIDEO_URL;
  video.crossOrigin = "anonymous";
  video.muted = true;
  video.setAttribute("muted", "");
  video.volume = 0;
  video.loop = true;
  video.playsInline = true;
  video.setAttribute("playsinline", "");
  video.setAttribute("webkit-playsinline", "");
  video.preload = "auto";

  video.style.position = "fixed";
  video.style.left = "-9999px";
  video.style.top = "-9999px";
  video.width = 1; video.height = 1;
  document.body.appendChild(video);

  const videoTex = new THREE.VideoTexture(video);
  videoTex.colorSpace = THREE.SRGBColorSpace;

  const screen = new THREE.Mesh(
    new THREE.PlaneGeometry(1.6, 0.9),
    new THREE.MeshBasicMaterial({ map: videoTex, transparent:true })
  );
  screen.position.set(0, 1.55, -1.35);
  scene.add(screen);

  // ---------- Texto 3D fijo (canvas + textura reutilizable) ----------
  // Ajustes visuales del texto
  const pad = 36;
  const fontPx = 56;
  const lineH = 78;
  const maxW = 1400;

  // Estado del “handwriting”
  const typeSettings = {
    minCps: 18,
    maxCps: 34,
    jitter: 0.35
  };

  let textPlane = null;
  let textCanvas = null;
  let textCtx = null;
  let textTexture = null;

  let typeAll = "";       // texto completo (con \n)
  let typeCursor = 0;     // índice en typeAll
  let typeNext = 0;       // temporizador para siguiente char (seg)
  let lastT = 0;

  // Medimos el tamaño del canvas usando el TEXTO COMPLETO una sola vez por cue
  function measureCanvasForLines(lines) {
    const c = document.createElement("canvas");
    const ctx = c.getContext("2d");
    ctx.font = `${fontPx}px ${fontName()}`;

    const safe = Array.isArray(lines) ? lines : [String(lines)];
    const w = Math.min(
      maxW,
      Math.max(...safe.map(l => ctx.measureText(l).width)) + pad*2
    );
    const h = safe.length * lineH + pad*2;

    return { w: Math.ceil(w), h: Math.ceil(h), safe };
  }

  function ensureTextResourcesForCue(lines) {
    const { w, h, safe } = measureCanvasForLines(lines);

    // (Re)crear canvas/textura solo cuando cambie el cue
    textCanvas = document.createElement("canvas");
    textCanvas.width = w;
    textCanvas.height = h;

    textCtx = textCanvas.getContext("2d");

    textTexture = new THREE.CanvasTexture(textCanvas);
    textTexture.minFilter = THREE.LinearFilter;
    textTexture.magFilter = THREE.LinearFilter;
    textTexture.generateMipmaps = false;

    // Crear plano con tamaño fijo (según aspect del canvas completo)
    const aspect = w / h;
    const physicalH = 0.30;
    const physicalW = physicalH * aspect;

    const mat = new THREE.MeshBasicMaterial({
      map: textTexture,
      transparent: true,
      depthWrite: false
    });

    if (textPlane) {
      textPlane.material.dispose();
      textPlane.geometry.dispose();
      scene.remove(textPlane);
    }

    textPlane = new THREE.Mesh(new THREE.PlaneGeometry(physicalW, physicalH), mat);
    textPlane.position.set(0, 1.23, -1.05); // fijo en el mundo
    scene.add(textPlane);

    // Guardamos texto completo para el typewriter
    typeAll = safe.join("\n");
    typeCursor = 0;
    typeNext = 0;

    // Limpiar canvas inicial (vacío)
    drawPartialText("");
  }

  function drawPartialText(partialText) {
    if (!textCtx) return;

    // Limpiar
    textCtx.clearRect(0, 0, textCanvas.width, textCanvas.height);

    // Estilo
    textCtx.font = `${fontPx}px ${fontName()}`;
    textCtx.textAlign = "center";
    textCtx.textBaseline = "middle";
    textCtx.fillStyle = "rgba(255,255,255,0.96)";
    textCtx.shadowColor = "rgba(0,0,0,0.85)";
    textCtx.shadowBlur = 20;
    textCtx.shadowOffsetY = 2;

    // Dibujar líneas (manteniendo las mismas posiciones siempre)
    const lines = String(partialText).split("\n");
    let y = pad + lineH/2;
    for (let i = 0; i < lines.length; i++) {
      textCtx.fillText(lines[i], textCanvas.width/2, y);
      y += lineH;
    }

    // Actualizar textura sin cambiar tamaño/posición
    textTexture.needsUpdate = true;
  }

  function randomCps() {
    const base = typeSettings.minCps + Math.random() * (typeSettings.maxCps - typeSettings.minCps);
    const jitter = 1 + (Math.random() * 2 - 1) * typeSettings.jitter;
    return Math.max(8, base * jitter);
  }

  function stepTypewriter(dt) {
    if (!typeAll || typeCursor >= typeAll.length) return;

    typeNext -= dt;
    while (typeNext <= 0 && typeCursor < typeAll.length) {
      typeCursor++;
      const partial = typeAll.slice(0, typeCursor);
      drawPartialText(partial);

      const cps = randomCps();
      typeNext += 1 / cps;
    }
  }

  // ---------- Cues ----------
  const cues = [...CUES].sort((a,b)=>a.t-b.t);
  let nextCue = 0;

  function resyncCues(t) {
    let idx = -1;
    for (let i=0; i<cues.length; i++) { if (cues[i].t <= t) idx = i; else break; }
    nextCue = idx + 1;
    if (idx >= 0) ensureTextResourcesForCue(cues[idx].text);
  }

  // Reinicio cues al hacer loop (si el tiempo salta atrás)
  let prevVideoTime = 0;
  function handleLoopReset(t) {
    if (t + 0.02 < prevVideoTime) { // saltó hacia atrás
      nextCue = 0;
      // limpia texto
      if (textCtx && textCanvas && textTexture) drawPartialText("");
    }
    prevVideoTime = t;
  }

  // ---------- Render loop ----------
  renderer.setAnimationLoop(() => {
    if (video.readyState >= 2) videoTex.needsUpdate = true;

    const t = video.currentTime;
    handleLoopReset(t);

    // Disparar cues
    while (nextCue < cues.length && t >= cues[nextCue].t) {
      ensureTextResourcesForCue(cues[nextCue].text);
      nextCue++;
    }

    const dt = Math.max(0, t - lastT);
    lastT = t;

    stepTypewriter(dt);

    renderer.render(scene, camera);
  });

  // ---------- Botones AR/VR ----------
  const btnStart = document.getElementById("start");
  const btnAR = document.getElementById("enterAR");
  const btnVR = document.getElementById("enterVR");

  async function enterSession(mode) {
    const session = await navigator.xr.requestSession(mode, {
      optionalFeatures:["local-floor","bounded-floor","hand-tracking"]
    });
    renderer.xr.setSession(session);
  }

  btnStart.onclick = async () => {
    try {
      log("▶️ Iniciando vídeo (loop)...");
      video.load();
      await video.play();
      lastT = video.currentTime;
      resyncCues(video.currentTime);
      btnAR.disabled = false;
      btnVR.disabled = false;
      log("✅ Vídeo OK. Ahora entra en AR/VR.");
    } catch (e) {
      log(`❌ Error vídeo: ${e?.name || "Error"}: ${e?.message || e}`);
    }
  };

  btnAR.onclick = async () => {
    try {
      const ok = await navigator.xr.isSessionSupported("immersive-ar");
      if (!ok) throw new Error("immersive-ar no soportado");
      await enterSession("immersive-ar");
      overlay.style.display="none";
    } catch (e) {
      log(`❌ AR: ${e?.message || e}`);
    }
  };

  btnVR.onclick = async () => {
    try {
      await enterSession("immersive-vr");
      overlay.style.display="none";
    } catch (e) {
      log(`❌ VR: ${e?.message || e}`);
    }
  };

  window.addEventListener("resize", ()=>{
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
</script>
</body>
</html>
