<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>XR Video + Texto 3D (AR)</title>
  <style>
    html,body{margin:0;height:100%;background:#000;overflow:hidden}
    #overlay{
      position:fixed;inset:0;display:grid;place-items:center;
      background:rgba(0,0,0,.85);color:#fff;
      font-family:system-ui,Arial;
      z-index:10;text-align:center;padding:24px;
    }
    .card{
      max-width:860px;width:100%;
      background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.12);
      border-radius:18px;padding:20px;
    }
    button{
      padding:14px 18px;border-radius:14px;
      border:1px solid rgba(255,255,255,.2);
      background:rgba(255,255,255,.1);
      color:#fff;cursor:pointer;margin:6px;
    }
    .log{
      opacity:.8;font-size:14px;line-height:1.4;
      margin-top:12px;white-space:pre-wrap;text-align:left
    }
  </style>
</head>
<body>

<div id="overlay">
  <div class="card">
    <h2>AR passthrough + vÃ­deo + texto 3D</h2>
    <p style="opacity:.9">
      1) Inicia el vÃ­deo (muted) Â· 2) Entra en AR Â· si no, usa VR
    </p>
    <div>
      <button id="start">1) Iniciar vÃ­deo</button>
      <button id="enterAR" disabled>2) Entrar en AR</button>
      <button id="enterVR" disabled>Entrar en VR</button>
    </div>
    <div class="log" id="log"></div>
  </div>
</div>

<script type="module">
  import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";
  import { FontLoader } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/loaders/FontLoader.js";
  import { TextGeometry } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/geometries/TextGeometry.js";
  import { CUES, VIDEO_URL } from "./cues.js";

  const logEl = document.getElementById("log");
  const log = m => logEl.textContent += (logEl.textContent ? "\n" : "") + m;

  /* ---------------- RENDERER / ESCENA ---------------- */
  const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio,2));
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.xr.enabled = true;
  document.body.appendChild(renderer.domElement);

  const scene = new THREE.Scene();
  scene.background = null;

  const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 50);
  camera.position.set(0,1.6,2);

  scene.add(new THREE.HemisphereLight(0xffffff,0x222222,1.2));
  scene.add(new THREE.DirectionalLight(0xffffff,0.6));

  /* ---------------- VIDEO (Quest safe) ---------------- */
  const video = document.createElement("video");
  video.src = VIDEO_URL;
  video.crossOrigin = "anonymous";
  video.muted = true;
  video.setAttribute("muted","");
  video.volume = 0;
  video.playsInline = true;
  video.setAttribute("playsinline","");
  video.setAttribute("webkit-playsinline","");
  video.preload = "auto";

  video.style.position="fixed";
  video.style.left="-9999px";
  video.style.top="-9999px";
  document.body.appendChild(video);

  const videoTex = new THREE.VideoTexture(video);
  videoTex.colorSpace = THREE.SRGBColorSpace;

  const screen = new THREE.Mesh(
    new THREE.PlaneGeometry(1.6,0.9),
    new THREE.MeshBasicMaterial({ map:videoTex, transparent:true })
  );
  screen.position.set(0,1.6,-2.2);
  scene.add(screen);

  const dimmer = new THREE.Mesh(
    new THREE.PlaneGeometry(6,4),
    new THREE.MeshBasicMaterial({ color:0x000000, transparent:true, opacity:0.55 })
  );
  dimmer.position.set(0,1.6,-2.6);
  scene.add(dimmer);

  /* ---------------- TEXTO 3D EXTRUIDO ---------------- */
  const FONT_URL = "./helvetiker_regular.typeface.json"; // ðŸ‘ˆ raÃ­z
  const fontLoader = new FontLoader();
  let font = null;
  let textGroup = null;

  const textMat = new THREE.MeshStandardMaterial({
    color:0xffffff,
    roughness:0.25,
    metalness:0.05
  });

  const TEXT_SIZE = 0.085;
  const TEXT_DEPTH = 0.02;
  const LINE_GAP = 0.11;
  const TEXT_POS = new THREE.Vector3(0,1.35,-1.0);

  function loadFont(){
    if(font) return Promise.resolve(font);
    return new Promise((res,rej)=>{
      fontLoader.load(
        FONT_URL,
        f=>{font=f;res(f)},
        undefined,
        e=>rej(e)
      );
    });
  }

  function clearText(){
    if(!textGroup) return;
    textGroup.traverse(o=>o.isMesh && o.geometry.dispose());
    scene.remove(textGroup);
    textGroup=null;
  }

  function lineMesh(txt){
    const geo = new TextGeometry(txt,{
      font,
      size:TEXT_SIZE,
      height:TEXT_DEPTH,
      bevelEnabled:true,
      bevelThickness:0.004,
      bevelSize:0.003,
      bevelSegments:3
    });
    geo.computeBoundingBox();
    const w = geo.boundingBox.max.x - geo.boundingBox.min.x;
    geo.translate(-w/2,0,0);
    return new THREE.Mesh(geo,textMat);
  }

  async function setText3D(lines){
    await loadFont();
    clearText();
    const arr = Array.isArray(lines)?lines:[String(lines)];
    textGroup = new THREE.Group();
    arr.forEach((l,i)=>{
      const m = lineMesh(l);
      m.position.y = ((arr.length-1)*LINE_GAP)/2 - i*LINE_GAP;
      textGroup.add(m);
    });
    textGroup.position.copy(TEXT_POS);
    scene.add(textGroup);
  }

  /* ---------------- CUES ---------------- */
  const cues = [...CUES].sort((a,b)=>a.t-b.t);
  let nextCue = 0;

  function resync(t){
    let idx=-1;
    for(let i=0;i<cues.length;i++){
      if(cues[i].t<=t) idx=i; else break;
    }
    nextCue=idx+1;
    if(idx>=0) setText3D(cues[idx].text);
  }

  /* ---------------- LOOP ---------------- */
  renderer.setAnimationLoop(()=>{
    if(video.readyState>=2) videoTex.needsUpdate=true;

    if(!video.paused && !video.ended){
      const t=video.currentTime;
      while(nextCue<cues.length && t>=cues[nextCue].t){
        setText3D(cues[nextCue].text);
        nextCue++;
      }
    }

    if(textGroup) textGroup.quaternion.copy(camera.quaternion);
    renderer.render(scene,camera);
  });

  window.addEventListener("resize",()=>{
    camera.aspect=window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth,window.innerHeight);
  });

  /* ---------------- AR / VR ---------------- */
  const startBtn=document.getElementById("start");
  const arBtn=document.getElementById("enterAR");
  const vrBtn=document.getElementById("enterVR");

  async function enter(mode){
    const session = await navigator.xr.requestSession(mode,{
      optionalFeatures:["local-floor","hit-test","anchors"]
    });
    renderer.xr.setSession(session);
    log("SesiÃ³n: "+mode);
  }

  startBtn.onclick=async()=>{
    try{
      log("Iniciando vÃ­deoâ€¦");
      video.load();
      await video.play();
      await loadFont();
      resync(video.currentTime);
      arBtn.disabled=false;
      vrBtn.disabled=false;
      log("OK");
    }catch(e){
      log("ERROR: "+e.message);
    }
  };

  arBtn.onclick=async()=>{
    try{
      const ok=await navigator.xr.isSessionSupported("immersive-ar");
      if(!ok) throw new Error("immersive-ar no soportado");
      await enter("immersive-ar");
      overlay.style.display="none";
    }catch(e){log(e.message);}
  };

  vrBtn.onclick=async()=>{
    try{
      await enter("immersive-vr");
      overlay.style.display="none";
    }catch(e){log(e.message);}
  };
</script>
</body>
</html>
