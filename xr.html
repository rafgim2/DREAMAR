<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>XR Video AR</title>
  <style>
    html,body{margin:0;height:100%;background:#000;overflow:hidden}
    #overlay{
      position:fixed;inset:0;
      display:grid;place-items:center;
      background:rgba(0,0,0,.85);
      color:#fff;font-family:system-ui,Arial;
      z-index:10;text-align:center;padding:24px;
    }
    .card{
      max-width:820px;width:100%;
      background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.12);
      border-radius:18px;padding:20px;
    }
    button{
      padding:14px 18px;border-radius:14px;
      border:1px solid rgba(255,255,255,.2);
      background:rgba(255,255,255,.1);
      color:#fff;cursor:pointer;margin:6px;
    }
    .small{opacity:.75;font-size:14px;line-height:1.4;margin-top:10px}
  </style>
</head>
<body>

<div id="overlay">
  <div class="card">
    <h2 style="margin:0 0 10px 0;">Experiencia AR</h2>
    <p style="margin:0 0 14px 0;opacity:.9;">
      1) Inicia el vídeo · 2) Entra en AR (passthrough)
    </p>
    <button id="start">1) Iniciar vídeo</button>
    <button id="enterAR" disabled>2) Entrar en AR</button>
    <div class="small" id="log"></div>
  </div>
</div>

<script type="module">
  import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";
  import { Text } from "https://unpkg.com/troika-three-text@0.49.0/dist/troika-three-text.esm.js";
  import { CUES, VIDEO_URL } from "./cues.js";

  const logEl = document.getElementById("log");
  const log = m => logEl.textContent += (logEl.textContent ? "\n" : "") + m;

  // ---------- Renderer (transparente para passthrough) ----------
  const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio,2));
  renderer.setSize(window.innerWidth,window.innerHeight);
  renderer.xr.enabled = true;
  document.body.appendChild(renderer.domElement);

  const scene = new THREE.Scene();
  scene.background = null;

  const camera = new THREE.PerspectiveCamera(60,window.innerWidth/window.innerHeight,0.1,50);
  camera.position.set(0,1.6,2);

  scene.add(new THREE.HemisphereLight(0xffffff,0x222222,1.2));

  // ---------- VIDEO ----------
  const video = document.createElement("video");
  video.src = VIDEO_URL;
  video.crossOrigin = "anonymous";
  video.muted = true;
  video.setAttribute("muted","");
  video.playsInline = true;
  video.setAttribute("playsinline","");
  video.setAttribute("webkit-playsinline","");
  video.preload = "auto";

  video.style.position="fixed";
  video.style.left="-9999px";
  document.body.appendChild(video);

  const videoTex = new THREE.VideoTexture(video);
  videoTex.colorSpace = THREE.SRGBColorSpace;

  const screen = new THREE.Mesh(
    new THREE.PlaneGeometry(1.6,0.9),
    new THREE.MeshBasicMaterial({ map:videoTex, transparent:true })
  );
  screen.position.set(0,1.6,-2.2);
  scene.add(screen);

  // ---------- TEXTO 3D REAL (Troika) ----------
  const textFront = new Text();
  textFront.text = "";
  textFront.fontSize = 0.095;
  textFront.lineHeight = 1.15;
  textFront.maxWidth = 1.2;
  textFront.anchorX = "center";
  textFront.anchorY = "middle";
  textFront.color = 0xffffff;
  textFront.outlineWidth = 0.004;
  textFront.outlineColor = 0x000000;
  textFront.position.set(0,1.35,-1.0);
  scene.add(textFront);

  // Extrusión (capas traseras)
  const EXTRUDE_LAYERS = 8;
  const EXTRUDE_STEP = 0.004;
  const extrudeMeshes = [];

  for(let i=1;i<=EXTRUDE_LAYERS;i++){
    const t = new Text();
    t.text="";
    t.fontSize = textFront.fontSize;
    t.lineHeight = textFront.lineHeight;
    t.maxWidth = textFront.maxWidth;
    t.anchorX = textFront.anchorX;
    t.anchorY = textFront.anchorY;
    t.color = 0x1a1a1a;
    t.position.set(
      textFront.position.x,
      textFront.position.y,
      textFront.position.z - i*EXTRUDE_STEP
    );
    scene.add(t);
    extrudeMeshes.push(t);
  }

  async function setText3D(lines){
    const content = Array.isArray(lines) ? lines.join("\n") : String(lines);
    textFront.text = content;
    await textFront.sync();
    for(const t of extrudeMeshes){
      t.text = content;
      await t.sync();
    }
  }

  // ---------- CUES ----------
  const cues = [...CUES].sort((a,b)=>a.t-b.t);
  let nextCue = 0;

  function resyncCues(t){
    let idx=-1;
    for(let i=0;i<cues.length;i++){
      if(cues[i].t<=t) idx=i; else break;
    }
    nextCue = idx+1;
    if(idx>=0) setText3D(cues[idx].text);
  }

  // ---------- LOOP ----------
  renderer.setAnimationLoop(()=>{
    if(video.readyState>=2) videoTex.needsUpdate=true;

    if(!video.paused && !video.ended){
      const t = video.currentTime;
      while(nextCue<cues.length && t>=cues[nextCue].t){
        setText3D(cues[nextCue].text);
        nextCue++;
      }
    }

    textFront.quaternion.copy(camera.quaternion);
    for(const t of extrudeMeshes) t.quaternion.copy(camera.quaternion);

    renderer.render(scene,camera);
  });

  // ---------- BOTONES ----------
  const btnStart = document.getElementById("start");
  const btnAR = document.getElementById("enterAR");

  btnStart.onclick = async ()=>{
    try{
      video.load();
      await video.play();
      resyncCues(video.currentTime);
      btnAR.disabled=false;
      log("Vídeo iniciado.");
    }catch(e){
      log("Error vídeo: "+e.message);
    }
  };

  btnAR.onclick = async ()=>{
    try{
      const ok = await navigator.xr.isSessionSupported("immersive-ar");
      if(!ok) throw new Error("immersive-ar no soportado");
      const session = await navigator.xr.requestSession("immersive-ar",{ optionalFeatures:["local-floor"] });
      renderer.xr.setSession(session);
      document.getElementById("overlay").style.display="none";
      log("AR iniciado.");
    }catch(e){
      log("AR error: "+e.message);
    }
  };

</script>
</body>
</html>
